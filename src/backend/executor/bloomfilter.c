#include "executor/bloomfilter.h"
#include "utils/elog.h"
#include "utils/palloc.h"
#include "lib/stringinfo.h"
#include <assert.h>
#include <math.h>

static uint32_t Rehash32to32(const uint32_t hash) {
    // Constants generated by uuidgen(1) with the -r flag
    uint64_t m = 0x7850f11ec6d14889ull, a = 0x6773610597ca4c63ull;
    // This is strongly universal hashing following Dietzfelbinger's "Universal hashing
    // and k-wise independent random variables via integer arithmetic without primes". As
    // such, for any two distinct uint32_t's hash1 and hash2, the probability (over the
    // randomness of the constants) that any subset of bit positions of
    // Rehash32to32(hash1) is equal to the same subset of bit positions
    // Rehash32to32(hash2) is minimal.
    return ((uint64_t)(hash) * m + a) >> 32;
}

void BloomFilterInit(BloomFilter *bf, int log_heap_space)
{
    assert(bf->directory == NULL);
    assert(log_heap_space<=32);
    bf->log_num_buckets = max(1, log_heap_space - LOG_BUCKET_WORD_BITS);
    bf->directory_mask = (1ull << min(63, bf->log_num_buckets)) - 1;
    bf->always_false = true;
    size_t bfsize = 1uLL << (bf->log_num_buckets + LOG_BUCKET_WORD_BITS);
    BloomFilterPrint(bf);
    bf->directory = palloc(bfsize);
    assert(bf->directory != NULL);
    memset(bf->directory, 0, bfsize);
    elog(LOG, "Create a bloomfilter with num_buckets:%d, size:%d",
              1<<bf->log_num_buckets, bfsize);
    //BloomFilterPrint(bf);
}

void BloomFilterInsert(BloomFilter *bf, uint32_t hash)
{
    bf->always_false = false;
    uint32_t bucket_idx = Rehash32to32(hash) & bf->directory_mask;
    uint32_t new_bucket[8];
    for (int i = 0; i < 8; ++i) {
      // Rehash 'hash' and use the top LOG_BUCKET_WORD_BITS bits, following Dietzfelbinger.
      new_bucket[i] =
          (REHASH[i] * hash) >> ((1 << LOG_BUCKET_WORD_BITS) - LOG_BUCKET_WORD_BITS);
      new_bucket[i] = 1U << new_bucket[i];
    }

    for (int i = 0; i < 2; ++i) {
        __m128i new_bucket_sse = _mm_load_si128((__m128i*)(new_bucket + 4 * i));
        __m128i* existing_bucket = (__m128i*)(&bf->directory[bucket_idx][4 * i]);
        *existing_bucket = _mm_or_si128(*existing_bucket, new_bucket_sse);
    }
    //BloomFilterPrint(bf);
}

bool BloomFilterFind(BloomFilter *bf, uint32_t hash)
{
    uint32_t bucket_idx = Rehash32to32(hash) & bf->directory_mask;
    for (int i = 0; i < BUCKET_WORDS; ++i)
    {
        BucketWord hval =
            (REHASH[i] * hash) >> ((1 << LOG_BUCKET_WORD_BITS) - LOG_BUCKET_WORD_BITS);
        hval = 1U << hval;
        if (!(bf->directory[bucket_idx][i] & hval))
        {
            return false;
        }
    }
    return true;
}

void BloomFilterPrint(BloomFilter *bf)
{
    StringInfo bfinfo = makeStringInfo();
    appendStringInfo(bfinfo, "##### Print Bloomfilter #####\n");
    appendStringInfo(bfinfo, "always_false:%d,", bf->always_false);
    appendStringInfo(bfinfo, "directory_mask: %x, ", bf->directory_mask);
    appendStringInfo(bfinfo, "log_num_buckets: %d\n s", bf->log_num_buckets);
    appendStringInfo(bfinfo, "directory:\n");
    if (bf->directory!=NULL) {
        for (int i = 0; i < (1<<bf->log_num_buckets); i++)
        {
            appendStringInfo(bfinfo, "bucket[%d]:", i);
            for (int j = 0; j < 8; j++)
                appendStringInfo(bfinfo, "%8x|", bf->directory[i][j]);
            appendStringInfo(bfinfo, "\n");
        }
    }
    appendStringInfo(bfinfo, "##### END Print Bloomfilter #####\n");
    if(bfinfo->data != NULL)
        pfree(bfinfo->data);
}

void BloomFilterDestroy(BloomFilter *bf)
{
    if (bf->directory != NULL)
    {
        pfree(bf->directory);
        bf->directory = NULL;
    }
}

/*
 * Get the False Positive Probability of a bloom filter
 */
double BloomFilterGetFPP(BloomFilter *bf, size_t ndv, int log_heap_space) {
  return pow(1 - exp((-1.0 * (double)(BUCKET_WORDS) * (double)ndv)
                     / (double)(1ull << (log_heap_space + 3))),
      BUCKET_WORDS);
}

/*
int main(int argc, char** argv){
    BloomFilter bf;
    memset(&bf, 0 , sizeof(bf));

    BloomFilterInit(&bf, 8);
    for (int i = 0; i < 100; i++)
        BloomFilterInsert(&bf, i);

    for (int i = 0; i < 100; i++)
    {
        int random = rand()%1000;
        if (BloomFilterFind(&bf, random) == true)
            printf("===>%d is in the set\n", random);
    }

    printf("GetFPP: %f\n", BloomFilterGetFPP(&bf, 100, 8));
    BloomFilterDestroy(&bf);
}
*/
